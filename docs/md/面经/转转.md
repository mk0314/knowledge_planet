<!--
 * @Author: mengkun822 1197235402@qq.com
 * @Date: 2023-11-25 08:20:56
 * @LastEditors: mengkun822 1197235402@qq.com
 * @LastEditTime: 2023-11-25 17:21:13
 * @FilePath: \knowledge_planet\docs\md\面经\转转.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->

### 热更新原理是什么？

热更新是指在应用程序运行过程中，通过动态替换部分或全部代码，实现应用程序的更新和升级。

一般来说，热更新会将新的代码打包成一个补丁包，然后在应用程序运行时下载并应用这个本补丁包，热更新主要有以下两种实现方式：

1. 文件替换

    - 运行时，将修改的文件进行替换
    - 这种方式需要对被替换的文件进行校验，以保证正确性，并且需要重启应用应用程序才能生效。

2. 代码注入
    - 运行时，将修改的代码注入到应用程序中
    - 这种方式不需要重启应用程序，只需要重新加载应用程序即可，并且代码注入不会改变应用程序原有的逻辑，因此更加安全。

热更新的实现原理主要是依赖应用程序的动态加载机制，在应用程序启动的时候，可以将一部分核心代码或者框架进行预加载，而其他业务代码则可以延迟加载，当需要更新时，只需要将新的代码替换到预加载的代码中，然后重新加载应用程序即可。

需要注意的是，热更新会存在一些问题和风险，比如代码的兼容性，数据结构变化导致的异常等。

### 原型和原型链

原型（prototype）是 JavaScript 的一个重要概念,他是实现继承和属性共享的基础。每个 JavaScript 对象都有一个原型，对象可以通过原型链来访问共享的属性和方法。

在 JS 中，每个对象（除了 null 外）都有一个内部链接到另一个对象， 这个对象就是原型。当我们尝试访问一个对象的属性或方法时，如果这个对象没有该方法和属性，js 就会沿着原型链向上查找，直到找到对应的属性和方法为止。

从技术角度来说，每个函数（除了箭头函数外）都有个 prototype 的属性，而每个实例对象都有个 prototype 内部属性指向他的原型对象，每个对象之间的委托关系就形成了原型链

原型作用是：实现继承、属性和方法共享 、原型链

原型链：使用来查找继承的属性和方法的。

### 继承

继承是面向对象编程的一个重要的概念，它允许一个对象获取另一个对象的属性和方法。

继承分为：

-   原型链继承：
    -   创建一个父对象的实例，并将其设置为子对象的原型。
    -   子对象通过原型链继承父对象的属性和方法。

```js
function Parent() {
    this.name = 'Parent';
}

Parent.prototype.sayName = function () {
    console.log('hello' + this.name);
};

function Child() {
    console.log('Child');
}

child.prototype = new Parent();

const child = new Child();

child.sayName(); // hello Child
```

-   构造函数继承

    -   在子对象的构造函数调用父对象的构造函数，使用 call 和 apply 方法

    -   这样子对象可以得到父对象的属性，但不能继承父对象的原型上的方法。

```js
function Parent() {
    this.name = "Parent";
},


function Child() {
    Parent.call(this);
    this.name = 'Child';
}


const child = new Child();

console.log(child.name) // Child
```

-   组合继承（原型链继承+构造函数继承）
    -   同时使用原型链和构造函数继承的方式
    -   子对象通过对原型继承父对象的方法，通过构造函数继承父对象属性。

```javaScript
function Parent() {
    this.name = 'Parent';
}

Parent.prototype.sayName = function () {
    console.log('hello' + this.name);
};

function Child() {
    Parent.call(this);
    this.name = 'Child';
}

Child.prototype = new Parent();

const child = new Child();

child.sayName();
```

### 设计模式

设计模式是在软件开发中解决问题的可复用的解决方案。它们提供了一种被广泛接受的最佳实践，可以帮助开发人员更高效的开发维护和可拓展的软件系统。

常见的设计模式有：

-   单例模式：确保一个类只有一个实例，并提供一个全局访问点。

-   工厂模式：通过使用工厂方法创建对象，而不能直接调用构造函数。

-   抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。

-   建造者模式： 讲一个复杂对象的构建过程于其表示分离，以便相同的构建过程可以创建不同的表示。

-   原型模式： 通过复制现有对象来创建新对象，而不是使用昂贵的创建操作。

-   适配器模式：将一个类的接口转换成客户端所期待的另一个接口。

-   装饰器模式：动态的给对象添加额外的职责。

-   观察者模式：定义了一种一对多的依赖关系，使得多个观察者对象同时监听一个主题对象，当主题对象发生变化时，他的所有依赖者（观察者）都会收到通知并更新。

-   策略模式：定义一系列算法，将这些算法封装起来，并使得它们可以互换使用。

-   模板方法模式： 定义个一个操作中的算法框架，将一些步骤延迟到子类中实现。

### 闭包

闭包简而言之，就是访问函数外部的变量，而函数外部访问函数内部的变量，就是闭包（访问作用域外部的变量）。

用途： 防抖，节流, 函数柯力化

#### 防抖和节流的区别

防抖和节流都是常用的优化技术，用于控制函数的执行频率，以提高程序的性能。

防抖：当触发一个事件后，如果在一定的时间内没有再次触发该函数，那么就只执行一次函数，如果在一定的时间内再次触发该函数，那么就重新计时。

节流：当触发一个事件后，在一定的时间间隔内只执行该事件的回调函数一次，如果在间隔时间内再次触发该事件则忽略触发，直到间隔时间过后才可以再次执行。

```js
// 防抖

function debounce(fn, delay) {
    let timer = null;

    return function () {
        if (timer) {
            clearTimeout(timer);
        }

        timer = setTimeout(() => {
            fn.call(this, arguments);
        }, 500);
    };
}

// 节流

function throttle(fn, delay) {
    let timer = null;

    return function () {
        if (timer) return;
        timer = setTimeout(() => {
            fn.call(this, arguments);
            timer = null;
        }, 500);
    };
}
```

### Vue 的 keep-alive 的原理

keep-alive 是 vue 的一个内置组件，用于在 Vue 应用中缓存和保留组件状态，以便在组件之间快速切换时，避免重新渲染和重新加载。

keep-alive 组件的原理是，当组件被切换时，keep-alive 会将组件的状态保存在内存中，而不是将其销毁，当再次切换到该组件时，keep-alive 会重新将组件的状态恢复到之前的状态，从而避免重新渲染和重新加载。

Vue 的 keep-alive 组件原理主要涉及两个方面：缓存管理和生命周期。

1. 缓存管理
   当使用 keep-alive 包裹组件时，该组件就会被缓存起来。具体实现方式是组件实例会保存在一个 cache 对象中，以组件的名称作为 key，组件实例作为 value。当需要渲染被缓存的组件的时候，vue 会从 cache 对象中查找对应的组件实例，如果找到，则直接渲染该组件实例，否则会创建一个新的组件实例。

2. 组件生命周期

由于组件可能会被多次激活，因此 vue 在处理这些组件的时候，需要对组件的生命周期进行管理。

-   当组件首次被激活的时候，vue 会触发 created、mounted、activated 生命周期钩子函数。

-   当组件再次被激活的时候，vue 会触发 activated 生命周期钩子函数。
-   当组件被销货的时候，vue 会触发 deactivated 生命周期的钩子函数。

除此之外，keep-alive 组件还提供了两个属性：include 和 exclude，用于指定哪些组件需要缓存，哪些组件不需要缓存。

### Vue 中的 nextTick 的原理

$nextTick 是 Vue 中的一个异步 api，用于在下次 DOM 更新之前执行一些操作，他的原理是基于 js 的事件循环机制。

当 vue 更新虚拟 DOM 并将其渲染到真实 DOM 时，它使用异步方式进行操作，而不是立即更新 DOM，这样可以避免频繁的 DOM 操作，从而提高性能。

当调用$nextTick()时，vue 会将传入的回调函数放入一个队列，等待下次 DOM 更新周期之前执行。这个任务会在当前代码块执行完毕后立即执行，但是在真实 dom 更新之前。

具体原理：

1. 当$nextTick()被调用时，vue 会将传入的回调函数放入一个队列中。

2. 在当前 js 执行栈执行完毕后，vue 会检查是否已经有一个异步任务在执行，如果没有，则会开启一个异步任务。

3. 在异步任务中，Vue 会遍历回调队列并依次执行每个回调函数。

4. 回调函数执行时，vue 会进行一次 dom 更新， 将所有的数据变化渲染到实际的 DOM。

5. 如果在执行回调函数的过程中产生了新的数据变化，Vue 会再次触发更新周期，以确保数据的正确性。

### Vue 的渲染过程

Vue 的渲染过程是将组件的模板转换成真实 dom 的过程

1. 解析模板：

    - 将模板字符串解析成 AST 语法树。Vue 采用的是 HTML parser 库来解析模板字符串，生成对应的 AST.

    - 优化 AST:对 AST 进行优化，如静态节点提取、静态属性提取，这些优化可以减少运行时的开销，提高性能。

    - 生成渲染函数：遍历 AST，生成可以执行的渲染函数。渲染函数接受一个“上下文”对象作为参数，用于获取组件的状态和属性，并返回一个虚拟 dom.

    - 生成静态根节点：根据 AST 生成静态节点，用于缓存组件实例。

2. 比较虚拟 dom：在每次组件发生变化时，Vue 会再次调用渲染函数生成新的虚拟 dom，然后根据 diff 算法比较新旧虚拟 dom，找出差异，并更新真实 dom.

### 浏览器的每一帧做了什么

在浏览器中，每一帧是指的是屏幕刷新一次的时间，通常情况下是以每秒 60 帧的速度进行，用于完成页面的渲染和用户的交互响应。

在浏览器中，每一帧会经历以下几个过程：

1. 事件处理：浏览器会检查是否有新的输入事件，如：点击事件，键盘输入、滚动等事件。如果有，则先处理这些事件。

2. 样式计算：浏览器会计算元素的最终样式，包括从 css 规则中解析样式属性，并计算出每个元素具体的样式值。

3. 布局：也称为回流，浏览器会根据元素的样式和尺寸计算出它们在页面上的精确位置，并且确定它们之间的相对关系。

4. 绘制：浏览器基于计算好的样式和布局信息，将页面内容绘制到内存中的位图缓存区。

5. 显示：将合成好的位图缓冲区内容发送到屏幕上显示给用户。

6. 帧的结束：浏览器完成一帧的渲染和显示后，会等待下一帧的输入。

### 浏览器缓存

浏览器缓存是指浏览器保存已经请求过的资源（如网页、图片、脚本等）的副本，并在下次请求的时候直接使用该副本，以节省网络带宽和提高加载速度。减轻服务器压力，减少网络延迟，提高用户体验。

浏览器的缓存分为协商缓存和强缓存两种：

#### 强缓存（HTTP Cache-Control 和 Expires）

-   Cache-Control 通过设置 Cache-Control 头信息为 max-age 来设置指定资源的缓存时间，在指定时间内，再次请求该资源，浏览器会直接从缓存中获取资源，不会与服务器进行交互。

-   Expires 是 http/1.0 的产物，通过设置 Expires 头部信息的过期时间。

#### 协商缓存（Last-Modified 和 Etag）

当强缓存失效后，浏览器会发送一个请求到服务器，通过比较资源的修改时间（last-modified）或者资源的唯一标识（Etag）来判断资源是否被修改，如果没有修改，服务器会返回一个 304 状态码，让浏览器直接使用缓存中的资源，如果修改了，则返回 200 和新的资源。

-   Last-Modified 表示 服务器通过 Last-modified 头部信息只是资源的最后修改时间，浏览器在下次请求时会将上一次缓存资源的修改时间发送给服务器，服务器通过比对资源的修改时间来判断资源是否被修改。

-   Etag 服务器通过 Etag 头部信息指示资源的唯一标识，浏览器在下次请求时会将上一次缓存的资源的 Etag 发送给服务器，服务器通过比较 Etag 来比较资源是否被修改。

#### Etag 的缺陷

Etag 是一种在协商缓存中使用的资源唯一标识符，虽然 Etag 在某些情况下是有效的，但是它也存在一些缺陷和限制。

-   计算成本过高: 生成 Etag 通过需要服务器计算资源，服务器需要重新计算资源，并且有可能效果相当大的计算成本，对于大型的网站来说，这有可能会对服务器性能产生负面影响。

-   资源变化带来的开销：当资源发生变化时，服务器需要重新计算和更新 Etag 值，并将其发给用户端，这会增加服务器的负载，并引入额外的网络开销。

-   分布式环境的问题：在分布式环境下，由于每一个赌气都有自己的 tag 计算逻辑，可能导致不同的服务器计算出的 Etag 值不同，从而导致协商缓存失败。

-   精确度问题： Etag 是基于资源内容的哈希值或者其他算法生成的，但不能保证绝对的唯一性。不同的算法或哈希碰撞可能会导致相同内容的资源具有不同的 Etag 值，这可能会影响到协商缓存的准确性。

-   弱校验机制：Etag 是服务器生成的，客户端无法验证 Etag 的有效性。
